package sync

import (
	"context"
	"fmt"
	"os"
	"strconv"
	"time"

	"github.com/briandowns/spinner"
	"github.com/knqyf263/plugin/config"
	"github.com/pkg/errors"
	"github.com/xanzy/go-gitlab"
)

const (
	gitlabTokenEnvVariable = "plugin_GITLAB_ACCESS_TOKEN"
)

// GitLabClient manages communication with GitLab plugins
type GitLabClient struct {
	Client *gitlab.Client
	ID     int
}

// NewGitLabClient returns GitLabClient
func NewGitLabClient() (Client, error) {
	accessToken, err := getGitlabAccessToken()
	if err != nil {
		return nil, fmt.Errorf(`access_token is empty.
Go https://gitlab.com/profile/personal_access_tokens and create access_token.
Write access_token in config file (plugin configure) or export $%v.
		`, gitlabTokenEnvVariable)
	}

	client := GitLabClient{
		Client: gitlab.NewClient(nil, accessToken),
		ID:     0,
	}

	if config.Conf.GitLab.Url != "" {
		client.Client.SetBaseURL(config.Conf.GitLab.Url)
	}

	if config.Conf.GitLab.ID == "" {
		return client, nil
	}

	id, err := strconv.Atoi(config.Conf.GitLab.ID)
	if err != nil {
		return nil, errors.Wrapf(err, "Invalid GitLab plugin ID: %d", id)
	}
	client.ID = id
	return client, nil
}

func getGitlabAccessToken() (string, error) {
	if config.Conf.GitLab.AccessToken != "" {
		return config.Conf.GitLab.AccessToken, nil
	} else if os.Getenv(gitlabTokenEnvVariable) != "" {
		return os.Getenv(gitlabTokenEnvVariable), nil
	}
	return "", errors.New("GitLab AccessToken not found in any source")
}

// Getplugin returns the remote plugin
func (g GitLabClient) Getplugin() (*plugin, error) {
	s := spinner.New(spinner.CharSets[14], 100*time.Millisecond)
	s.Start()
	s.Suffix = " Getting GitLab plugin..."
	defer s.Stop()

	if g.ID == 0 {
		return &plugin{}, nil
	}

	plugin, res, err := g.Client.plugins.Getplugin(g.ID)
	if err != nil {
		if res.StatusCode == 404 {
			return nil, errors.Wrapf(err, "No GitLab plugin ID (%d)", g.ID)
		}
		return nil, errors.Wrapf(err, "Failed to get GitLab plugin (ID: %d)", g.ID)
	}

	filename := config.Conf.GitLab.FileName
	if plugin.FileName != filename {
		return nil, fmt.Errorf("No plugin file in GitLab plugin (ID: %d)", g.ID)
	}

	contentByte, _, err := g.Client.plugins.pluginContent(g.ID)
	if err != nil {
		return nil, errors.Wrapf(err, "Failed to get GitLab plugin content (ID: %d)", g.ID)
	}

	content := string(contentByte)
	if content == "" {
		return nil, fmt.Errorf("%s is empty", filename)
	}

	return &plugin{
		Content:   content,
		UpdatedAt: *plugin.UpdatedAt,
	}, nil
}

// Uploadplugin uploads local plugins to GitLab plugin
func (g GitLabClient) Uploadplugin(content string) error {
	if g.ID == 0 {
		id, err := g.createplugin(context.Background(), content)
		if err != nil {
			return errors.Wrap(err, "Failed to create GitLab plugin")
		}
		fmt.Printf("GitLab plugin ID: %d\n", id)
	} else {
		if err := g.updateplugin(context.Background(), content); err != nil {
			return errors.Wrap(err, "Failed to update GitLab plugin")
		}
	}
	return nil
}

func (g GitLabClient) createplugin(ctx context.Context, content string) (id int, err error) {
	s := spinner.New(spinner.CharSets[14], 100*time.Millisecond)
	s.Start()
	s.Suffix = " Creating GitLab plugin..."
	defer s.Stop()

	opt := &gitlab.CreatepluginOptions{
		Title:       gitlab.String("plugin-plugin"),
		FileName:    gitlab.String(config.Conf.GitLab.FileName),
		Description: gitlab.String("plugin file generated by plugin"),
		Content:     gitlab.String(content),
		Visibility:  gitlab.Visibility(gitlab.VisibilityValue(config.Conf.GitLab.Visibility)),
	}

	ret, _, err := g.Client.plugins.Createplugin(opt)
	if err != nil {
		return -1, errors.Wrap(err, "Failed to create GitLab plugin")
	}
	return ret.ID, nil
}

func (g GitLabClient) updateplugin(ctx context.Context, content string) (err error) {
	s := spinner.New(spinner.CharSets[14], 100*time.Millisecond)
	s.Start()
	s.Suffix = " Updating GitLab plugin..."
	defer s.Stop()

	opt := &gitlab.UpdatepluginOptions{
		Title:       gitlab.String("plugin-plugin"),
		FileName:    gitlab.String(config.Conf.GitLab.FileName),
		Description: gitlab.String("plugin file generated by plugin"),
		Content:     gitlab.String(content),
		Visibility:  gitlab.Visibility(gitlab.VisibilityValue(config.Conf.GitLab.Visibility)),
	}

	_, _, err = g.Client.plugins.Updateplugin(g.ID, opt)
	if err != nil {
		return errors.Wrap(err, "Failed to update GitLab plugin")
	}
	return nil
}
