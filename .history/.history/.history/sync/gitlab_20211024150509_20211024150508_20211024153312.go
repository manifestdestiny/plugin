package sync

import (
	"context"
	"fmt"
	"os"
	"strconv"
	"time"

	"github.com/briandowns/spinner"
	"github.com/256bit-src/pet/config"
	"github.com/pkg/errors"
	"github.com/xanzy/go-gitlab"
)

const (
	gitlabTokenEnvVariable = "PET_GITLAB_ACCESS_TOKEN"
)

// GitLabClient manages communication with GitLab cli-plugin-snippets
type GitLabClient struct {
	Client *gitlab.Client
	ID     int
}

// NewGitLabClient returns GitLabClient
func NewGitLabClient() (Client, error) {
	accessToken, err := getGitlabAccessToken()
	if err != nil {
		return nil, fmt.Errorf(`access_token is empty.
Go https://gitlab.com/profile/personal_access_tokens and create access_token.
Write access_token in config file (pet configure) or export $%v.
		`, gitlabTokenEnvVariable)
	}

	client := GitLabClient{
		Client: gitlab.NewClient(nil, accessToken),
		ID:     0,
	}

	if config.Conf.GitLab.Url != "" {
		client.Client.SetBaseURL(config.Conf.GitLab.Url)
	}

	if config.Conf.GitLab.ID == "" {
		return client, nil
	}

	id, err := strconv.Atoi(config.Conf.GitLab.ID)
	if err != nil {
		return nil, errors.Wrapf(err, "Invalid GitLab cli-plugin-snippet ID: %d", id)
	}
	client.ID = id
	return client, nil
}

func getGitlabAccessToken() (string, error) {
	if config.Conf.GitLab.AccessToken != "" {
		return config.Conf.GitLab.AccessToken, nil
	} else if os.Getenv(gitlabTokenEnvVariable) != "" {
		return os.Getenv(gitlabTokenEnvVariable), nil
	}
	return "", errors.New("GitLab AccessToken not found in any source")
}

// Getcli-plugin-snippet returns the remote cli-plugin-snippet
func (g GitLabClient) Getcli-plugin-snippet() (*cli-plugin-snippet, error) {
	s := spinner.New(spinner.CharSets[14], 100*time.Millisecond)
	s.Start()
	s.Suffix = " Getting GitLab cli-plugin-snippet..."
	defer s.Stop()

	if g.ID == 0 {
		return &cli-plugin-snippet{}, nil
	}

	cli-plugin-snippet, res, err := g.Client.cli-plugin-snippets.Getcli-plugin-snippet(g.ID)
	if err != nil {
		if res.StatusCode == 404 {
			return nil, errors.Wrapf(err, "No GitLab cli-plugin-snippet ID (%d)", g.ID)
		}
		return nil, errors.Wrapf(err, "Failed to get GitLab cli-plugin-snippet (ID: %d)", g.ID)
	}

	filename := config.Conf.GitLab.FileName
	if cli-plugin-snippet.FileName != filename {
		return nil, fmt.Errorf("No cli-plugin-snippet file in GitLab cli-plugin-snippet (ID: %d)", g.ID)
	}

	contentByte, _, err := g.Client.cli-plugin-snippets.cli-plugin-snippetContent(g.ID)
	if err != nil {
		return nil, errors.Wrapf(err, "Failed to get GitLab cli-plugin-snippet content (ID: %d)", g.ID)
	}

	content := string(contentByte)
	if content == "" {
		return nil, fmt.Errorf("%s is empty", filename)
	}

	return &cli-plugin-snippet{
		Content:   content,
		UpdatedAt: *cli-plugin-snippet.UpdatedAt,
	}, nil
}

// Uploadcli-plugin-snippet uploads local cli-plugin-snippets to GitLab cli-plugin-snippet
func (g GitLabClient) Uploadcli-plugin-snippet(content string) error {
	if g.ID == 0 {
		id, err := g.createcli-plugin-snippet(context.Background(), content)
		if err != nil {
			return errors.Wrap(err, "Failed to create GitLab cli-plugin-snippet")
		}
		fmt.Printf("GitLab cli-plugin-snippet ID: %d\n", id)
	} else {
		if err := g.updatecli-plugin-snippet(context.Background(), content); err != nil {
			return errors.Wrap(err, "Failed to update GitLab cli-plugin-snippet")
		}
	}
	return nil
}

func (g GitLabClient) createcli-plugin-snippet(ctx context.Context, content string) (id int, err error) {
	s := spinner.New(spinner.CharSets[14], 100*time.Millisecond)
	s.Start()
	s.Suffix = " Creating GitLab cli-plugin-snippet..."
	defer s.Stop()

	opt := &gitlab.Createcli-plugin-snippetOptions{
		Title:       gitlab.String("pet-cli-plugin-snippet"),
		FileName:    gitlab.String(config.Conf.GitLab.FileName),
		Description: gitlab.String("cli-plugin-snippet file generated by pet"),
		Content:     gitlab.String(content),
		Visibility:  gitlab.Visibility(gitlab.VisibilityValue(config.Conf.GitLab.Visibility)),
	}

	ret, _, err := g.Client.cli-plugin-snippets.Createcli-plugin-snippet(opt)
	if err != nil {
		return -1, errors.Wrap(err, "Failed to create GitLab cli-plugin-snippet")
	}
	return ret.ID, nil
}

func (g GitLabClient) updatecli-plugin-snippet(ctx context.Context, content string) (err error) {
	s := spinner.New(spinner.CharSets[14], 100*time.Millisecond)
	s.Start()
	s.Suffix = " Updating GitLab cli-plugin-snippet..."
	defer s.Stop()

	opt := &gitlab.Updatecli-plugin-snippetOptions{
		Title:       gitlab.String("pet-cli-plugin-snippet"),
		FileName:    gitlab.String(config.Conf.GitLab.FileName),
		Description: gitlab.String("cli-plugin-snippet file generated by pet"),
		Content:     gitlab.String(content),
		Visibility:  gitlab.Visibility(gitlab.VisibilityValue(config.Conf.GitLab.Visibility)),
	}

	_, _, err = g.Client.cli-plugin-snippets.Updatecli-plugin-snippet(g.ID, opt)
	if err != nil {
		return errors.Wrap(err, "Failed to update GitLab cli-plugin-snippet")
	}
	return nil
}
